# 004 - The LLVM Intermediate Representation

## Intro
* First thing to keep in mind is that the LLVM IR is, indeed, a programming language. Nothing stops us from writing programs using the LLVM IR.
* The LLVM IR is a low-level programming language since it is closer to an assembly language than it is to a high-level programming language like Python, JavaScript, etc.
* The LLVM IR is both __analyzable and optimizable.__

## First Example
* This section is used to show us an example of a simple program written in C and the corresponding program written in LLVM IR (the file whose content is LLVM IR was automatically generated by ```clang``` with the command: ```clang -S -emit-llvm file.c -o file.ll```).
* ```file.c```:
```c
int callee(const int* X){
  return *X + 1;
}

int main(){
  int T = 4;
  return callee(&T); // returns 5
}
```
* ```file.ll```
```llvm
define dso_local i32 @callee(i32* %X) #0 {
entry:
  %X.addr = alloca i32*, align 8
  store i32* %X, i32** %X.addr, align 8
  %0 = load i32*, i32** %X.addr, align 8
  %1 = load i32, i32* %0, align 4
  %add = add nsw i32 %1, 1
  ret i32 %add
}

define dso_local i32 @main() #0 {
entry:
  %retval = alloca i32, align 4
  %T = alloca i32, align 4
  store i32 0, i32* %retval, align 4
  store i32 4, i32* %T, align 4
  %call = call i32 @callee(i32* %T)
  ret i32 %call
}
```
* __Notes:__
  * The program is in an assembly like format. This means that each function is formed by a linear sequence of instructions. Each instruction has an opcode and an opcode is the name of the operation that the instruction runs.
  * For example inside the function ```@callee```, we have __6 instructions, but just 5 different opcodes.__
  * Now considering the function ```@main```, we have __6 instructions, but just 4 different opcodes.__
  * Another thing to pay attention is the fact that the LLVM IR is typed. One can think of it like a "typed assembly". In practice, this means that every value has a type.
  * On this program, for example, we have 3 different types:
    * ```i32```: 32-bits Integer.
    * ```i32*```: Pointer to 32-bits Integer.
    * ```i32**```: Pointer to Pointer to 32-bits Integer. (These are usually auxiliar variables that the compiler needs to implement the program).
  * It is possible to optimize the generated LLVM IR program by using a sequence of commands:
  ```sh
  clang -Xclang -disable-O0-optnone -S -emit-llvm file.c -o file.ll
  opt -S -mem2reg file.ll -o file_opt.ll
  ```
  * The optimization called ```mem2reg``` basically moves variables that are stack allocated to registers.
  * The optimized version of the ```@callee``` function is shown below:
  ```llvm
  define dso_local i32 @callee(i32* %X) #0 {
  entry:
    %0 = load i32, i32* X, align 4
    %add = add nsw i32 %0, 1
    ret i32 %add
  }
  ```
  * The registers used in a program written in LLVM IR are not physical/architecture registers. They are virtual registers that can be mapped to physical/architecture ones, once the machine code (assembly for a specific target architecture) is generated.

## Optimized Second Example
* ```file.c```:
```c
int callee(const int X){
  return X + 1;
}

int main(){
  int T = 4;
  return callee(T); // returns 5
}
```
* ```file_mem2reg_opt.ll```:
```llvm
define dso_local i32 @callee(i32* %X) #0 {
entry:
  %add = add nsw i32 %X, 1
  ret i32 %add
}

define dso_local i32 @main() #0 {
entry:
  %call = call i32 @callee(i32 4)
  ret i32 %call
}
```

## Translatable
* The LLVM IR is translatable to other program formats that keep the same program semantics. That is, the meaning of the program is not changed.
* For example, we can perform the following translations without any problems:
  * Translating LLVM IR to LLVM Bitcode (a binary representation from the LLVM infrastructure):
  ```sh
  llvm-as callee_opt.ll -o callee_opt.bc
  ```
  * Translating the LLVM Bitcode to x86-Assembly:
  ```sh
  llc callee_opt.bc -o callee_opt.x86
  ```
  * Translating the x86-Assembly to Object Code:
  ```sh
  $LINUX/as callee_opt.x86 -o callee_opt.o
  ```
